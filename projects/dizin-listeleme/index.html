<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Language" content="tr" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- SEO Meta Etiketleri -->
    <title>Dizin Listeme (python) | MEFAMEX-PROJECTS</title>
    <meta name="author" content="Mefamex" />
    <meta name="description" content="Proje ismi: Dizin-listeleme | Yazılım Dili: Python | Açıklama: Dizindeki dosyalar ve klasörlerin komut istemcisi üzerinde ayrıntılarıntılarını görme." />
    <meta name="keywords" content="project, proje, mefamex proje, file lister, dizin listeleme, python, python project" />
    <meta name="robots" content="index, follow, max-image-preview:large" />
    <meta name="googlebot" content="index, follow" />
    <!-- Preconnect ve DNS Prefetch -->
    <link rel="preconnect" href="https://mefamex.com" />
    <link rel="dns-prefetch" href="https://mefamex.com" />
    <!-- Canonical Link -->
    <link rel="canonical" href="https://mefamex.com/projects/dizin-listeleme/" />
    <!-- Stil Optimizasyonu -->
    <link rel="stylesheet" href="page_aside.css" class="alternatively" />
    <link rel="preload" as="style" href="../../src/components/headerFooter.css" class="alternatively" />
    <!-- favicon set -->
    <link rel="icon" sizes="16x16" href="../../src/assets/images/mfmx/mfmx-16.png" type="image/png" />
    <link rel="icon" sizes="32x32" href="../../src/assets/images/mfmx/mfmx-32.png" type="image/png" />
    <link rel="icon" sizes="64x64" href="../../src/assets/images/mfmx/mfmx-64.png" type="image/png" />
    <link rel="icon" sizes="144x144" href="../../src/assets/images/mfmx/mfmx-144.png" type="image/png" />
    <link rel="icon" sizes="256x256" href="../../src/assets/images/mfmx/mfmx-256.png" type="image/png" />
    <link rel="icon" sizes="512x512" href="../../src/assets/images/mfmx/mfmx-512.png" type="image/png" />
    <link rel="apple-touch-icon" sizes="144x144" href="../../src/assets/images/mfmx/mfmx-144.png" />
    <!-- Open Graph Meta Etiketleri -->
    <meta property="og:title" content="Dizin Listeme (python) | MEFAMEX-PROJECTS" />
    <meta property="og:description"
        content="Dizin Yapısı Görselleştirme Aracı: Python ile yazılmış, dizinlerdeki dosya ve klasörlerin detaylı analizini yaparak disk kullanımını optimize etmeye yardımcı olan bir uygulama." />
    <meta property="og:creator" content="@mefamex" />
    <meta property="og:image" content="https://mefamex.com/src/assets/images/mfmx/mfmx-144.png" />
    <meta property="og:url" content="https://mefamex.com/projects/dizin-listeleme/" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="MEFAMEX" />
    <meta property="og:date" content="2025-03-02T02:00:00Z" />
    <meta property="og:locale" content="tr_TR" />
    <meta property="article:modified_time" content="2025-03-02T02:00:00Z" />
    <!-- Twitter Meta Etiketleri -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="Mefamex" />
    <meta name="twitter:creator" content="@mefamex" />
    <meta name="twitter:title" content="Dizin Listeme (python) | MEFAMEX-PROJECTS" />
    <meta name="twitter:description"
        content="Dizin Yapısı Görselleştirme Aracı: Python ile yazılmış, dizinlerdeki dosya ve klasörlerin detaylı analizini yaparak disk kullanımını optimize etmeye yardımcı olan bir uygulama." />
    <meta name="twitter:image" content="https://mefamex.com/src/assets/images/mfmx/mfmx-144.png" />
    <meta name="twitter:url" content="https://mefamex.com/projects/dizin-listeleme/" />
    <meta name="twitter:type" content="website" />
    <meta name="twitter:date" content="2025-03-02T02:00:00Z" />
    <style>
        #main_container main {
            section {
                flex: 1 1 20rem;
                min-height: 10rem;
                width: 20rem;
            }
        }
    </style>
    <!---->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" defer>  </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js" defer>  </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" defer>  </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js" defer>  </script>
</head>

<body>
    <div id="main_container">
        <main role="main" id="main" name="main" aria-label="Ana içerik">
            <section id="mainWellcome">
                <h1>DİZİN LİSTELEME</h1>
                <p>Bu Python uygulaması, belirtilen bir dizin yolundaki tüm dosya ve dizinleri detaylı bir görselleştirir.</p>
                <p>Dosya boyutları, oluşturulma tarihleri, dizin hiyerarşisi gibi bilgileri görsel ve metinsel olarak sunar.</p>
                <p>Github Proje Sayfası: <a href="https://github.com/Mefamex/Directory_Explorer">github.com/Mefamex/Directory_Explorer</a></p>
            </section>
            <section>
                <h2>Ana Özellikler: </h2>
                <ul>
                    <li>Rekürsif Dizin Gezimi:** Belirtilen dizin ve tüm alt dizinlerini inceler.</li>
                    <li>Detaylı Bilgi Toplama:** Dosya boyutu, oluşturulma tarihi, dizin derinliği gibi bilgileri hesaplar.</li>
                    <li>Formatlı Çıkış:** Tablo şeklinde okunaklı bir terminal çıktısı sunar.</li>
                    <li>Metin Dosyasına Kaydetme:** Sonuçları bir metin dosyasına kaydeder.</li>
                    <li>Özelleştirilebilir:** Çıkış formatı, analiz derinliği gibi ayarlar yapılabilir.</li>
                </ul>
            </section>
            <section>
                <h2>Kullanılan Modüller:</h2>
                <ul>
                    <li>os</li>
                    <li>datetime</li>
                </ul>
            </section>
            <section class="section_code_full">
                <h2>Script (python)</h2>
                <!--code tag with pre attribute bot not with pre tag-->
                <pre class="line-numbers"><code  class="language-python"># -*- coding: utf-8 -*-
# Created on Sunday, August 25 13:30:00 2024
# @author: mefamex

print(
    "\n",
    "#" * 30,
    """
    **Dizin Yapısı Görselleştirme Aracı**

    Bu Python uygulaması, belirtilen bir dizin yolundaki tüm dosya ve dizinleri detaylı bir şekilde analiz eder.
    Dosya boyutları, oluşturulma tarihleri, dizin hiyerarşisi gibi bilgileri görsel ve metinsel olarak sunar.
    Sistem yöneticileri, geliştiriciler ve veri bilimcileri için disk kullanımını optimize etmek, dosya yönetimini
    kolaylaştırmak ve veri analizi yapmak için ideal bir araçtır.

    **Ana Özellikler:**
    * **Rekürsif Dizin Gezimi:** Belirtilen dizin ve tüm alt dizinlerini inceler.
    * **Detaylı Bilgi Toplama:** Dosya boyutu, oluşturulma tarihi, dizin derinliği gibi bilgileri hesaplar.
    * **Formatlı Çıkış:** Tablo şeklinde okunaklı bir terminal çıktısı sunar.
    * **Metin Dosyasına Kaydetme:** Sonuçları bir metin dosyasına kaydeder.
    * **Özelleştirilebilir:** Çıkış formatı, analiz derinliği gibi ayarlar yapılabilir.

    **Kullanılan Modüller:**
    * os modülü
    * datetime modülü

    **Uyarılar:**
    * Çok büyük dizinlerde performans düşüşü yaşanabilir.
    * Dosya erişim hakları konusunda dikkatli olunmalıdır.
##################################################################################""",
    sep="",
)

import os, datetime


class DirExVis:
    """This class walks a directory tree, gathers information about files and directories, and presents it in a formatted way.

    Bu sınıf, bir dizin yapısını gezerek, dosya ve dizinler hakkında bilgi toplar ve biçimlendirilmiş bir şekilde sunar.
    """

    tab_size: int = 4
    details_size, details_date, details_folderCount = False, False, False
    width: int = 35
    maxNameLength: list = [0, 0]  # name, depth

    @staticmethod
    def unixToDate(unix: int | float) -> str:
        """Unix zaman damgasını okunabilir bir tarih ve saat dizesine çevirir.
        Args:
            unix (int | float): Unix zaman damgası (epoch'tan itibaren geçen saniye sayısı).
        Returns:
            str: Biçimlendirilmiş tarih ve saat dizesi (YYYY-MM-DD HH:MM:SS)."""
        return datetime.datetime.fromtimestamp(unix).strftime("%Y-%m-%d %H:%M:%S")

    def __init__(self, path: str = "", data: dict = {}):
        """This method initializes the DirExVis class.
            It takes an optional path argument, which specifies the starting directory.
            It also takes an optional data dictionary to store file and directory information.

        Args:
            path (str, optional): The starting directory path. Defaults to the current working directory.
            data (dict, optional): A dictionary to store file and directory information. Defaults to an empty dictionary.

        Bu method DirExVis sınıfını başlatır.
        İsteğe bağlı olarak bir başlangıç dizini yolu alan bir path argümanı alır.
        Ayrıca, dosya ve dizin bilgilerini saklamak için isteğe bağlı bir data sözlüğü alır.

        Args:
            path (str, isteğe bağlı): Başlangıç dizini yolu. Varsayılan olarak mevcut çalışma dizini.
            data (dict, isteğe bağlı): Dosya ve dizin bilgilerini saklamak için bir sözlük. Varsayılan olarak boş bir sözlük.
        """
        self.path: str = path if path != "" else os.getcwd()
        os.chdir(self.path)
        self.path = os.getcwd()
        self.datas: dict = (
            {}
        )  # { "name" : [depth(int) ,type (file/dir) , size , date , {childs}]  }

        self.data_str: str = ""
        self.printAll_dotted: bool = True
        self.start()
        self.saveDirExVis()

    def walker(self, path="", depth=0, data: dict = None):
        """Recursively traverses a directory structure and collects file and directory information.

                This method systematically explores a directory and its subdirectories, gathering details
                about each file and directory encountered. Collected information includes the file or
                directory name, type, size, modification time, and depth within the directory hierarchy.
                The gathered data is stored in a dictionary for further processing or analysis.

        Args:
            self: A reference to the `DirExVis` object.
            path (str, optional): The path of the directory to start traversing. Defaults to the current directory.
            depth (int, optional): The current depth level within the directory structure. Defaults to 0.
            data (dict, optional): A dictionary to store file and directory information. Defaults to `self.datas`.

        Returns:
            None


        Bu metot, belirtilen bir dizin yolundan başlayarak tüm alt dizinleri ve dosyaları rekürsif olarak inceler.
                Her bir dosya veya dizin için belirli bilgileri (ad, tür, boyut, son değiştirme tarihi, derinlik)
                toplar ve `data` sözlüğünde saklar.

        Args:
            self: DirExVis sınıfının bir örneği.
            path (str, optional): Gezinilecek dizinin yolu. Varsayılan olarak mevcut çalışma dizini.
            depth (int, optional): Gezinilen dizinin derinliği. Varsayılan olarak 0.
            data (dict, optional): Dosya ve dizin bilgilerini saklamak için bir sözlük. Varsayılan olarak `self.datas`.

        Returns:
            None
        """

        if path == "":
            path = self.path + ""
        if data is None:
            data = self.datas
        files = []
        for entry in os.listdir(path):
            entry_path = os.path.join(path, entry)
            if os.path.isdir(entry_path):
                data[entry] = [
                    depth + 1,
                    "dir",
                    0,
                    self.unixToDate(os.path.getmtime(entry_path)),
                    {},
                ]
                maxNameLength = [
                    max(DirExVis.maxNameLength[0], len(entry)),
                    max(DirExVis.maxNameLength[1], depth),
                ]
                self.printAll(data={entry: data[entry]})
                self.walker(entry_path, depth=depth + 1, data=data[entry][4])
            else:
                files.append(entry)

        for file in files:
            os.chdir(path)
            size = os.path.getsize(file)
            mtime = self.unixToDate(os.path.getmtime(file))
            DirExVis.maxNameLength[0] = max(DirExVis.maxNameLength[0], len(file))
            data[file] = [depth + 1, " file", size, mtime]
            self.printAll(data={file: data[file]})

    def printAll(self, data={}):
        """Recursively prints file and directory information in a formatted manner.

        This method iterates through the provided `data` dictionary, which contains information about files and directories.
        It formats the output using indentation, size, date, and folder count information, and prints it to the console.
        The method also recursively calls itself to print information for subdirectories.

        Args:
            self: A reference to the `DirExVis` object.
            data (dict, optional): A dictionary containing file and directory information. Defaults to `self.datas`.

        Returns:
            None

        Dosya ve dizin bilgilerini formatlı bir şekilde ekrana yazdırır.

            Bu metot, verilen `data` sözlüğündeki dosya ve dizin bilgilerini alır ve indentasyon, boyut, tarih ve klasör sayısı
            gibi bilgileri kullanarak formatlar. Sonra bu formatlanmış çıktıyı ekrana yazdırır. Alt dizinler için de
            aynı işlemi tekrarlar.

        Args:
            self: DirExVis sınıfının nesnesi .
            data (dict, optional): Dosya ve dizin bilgilerini içeren bir sözlük. Varsayılan olarak `self.datas`'ı kullanır.

        Returns:
            None
        """

        if data == {}:
            data = self.datas
        for key in data.keys():
            value = data[key]
            bas: str = ("|" + " " * DirExVis.tab_size) * value[0]
            folderCount: str = (
                ("(" + str(len(value[4])) + ")" if value[1] == "dir" else "")
                if DirExVis.details_folderCount
                else ""
            )
            size: str = (
                str(round(value[2] / (1024 * 1024), 3)) + "mb "
                if DirExVis.details_size
                else ""
            )
            date: str = str(value[3]) if DirExVis.details_date else ""
            arabosluk: str = (
                " "
                * (
                    DirExVis.width
                    + DirExVis.maxNameLength[0]
                    + DirExVis.maxNameLength[1] * DirExVis.tab_size
                    - len(bas + key + folderCount + size + date)
                )
                if len(size + date) > 0
                else ""
            )
            self.printAll_dotted = not self.printAll_dotted
            if self.printAll_dotted:
                arabosluk = arabosluk.replace(" ", "-")
            self.data_str += f"{bas}{key}{folderCount}{arabosluk}{size}{date}\n"
            print(f"{bas}{key}{folderCount}{arabosluk}{size}{date}")
            if value[1] == "dir" and len(value[4]) > 0:
                self.printAll(value[4])

    def saveDirExVis(self):
        """Saves the collected file and directory information to a text file.

        This method writes the formatted output of the file and directory structure to a text file.
        The formatted output is stored in the `data_str` attribute of the `DirExVis` object.

        Filename Generation:
            * A unique filename is created starting with "DirExVis_".
            * The current timestamp is appended in a human-readable format (replacing colons with periods).
            * A ".txt" extension is added to indicate a text file. This ensures that each save operation creates a new file.

        Data Saving:
            * The `data_str` attribute, containing the formatted output, is written to the newly created file.

        Args:
            self: A reference to the `DirExVis` object.

        Returns:
            None

        Toplanan dosya ve dizin bilgilerini bir metin dosyasına kaydeder.

        Bu metot, `walker` metodu tarafından toplanan dosya ve dizin bilgilerini okunaklı bir
        şekilde bir metin dosyasına kaydeder. Kaydedilen bilgiler, `printAll` metodu tarafından
        oluşturulan `data_str` değişkeninde saklanır.

        Dosya Adı Oluşturma:
            * Dosya adı "DirExVis_" ile başlar.
            * Ardından, geçerli zaman damgası insan tarafından okunabilir
                bir formata dönüştürülür (iki nokta yerine nokta kullanılır).
            * Son olarak, ".txt" uzantısı eklenir. Bu sayede, benzersiz
                bir dosya adı oluşturulur ve mevcut dosyaların üzerine yazılmaz.

        Veri Kaydetme:
            * `data_str` değişkeni, açılan metin dosyasına yazılır.

        Args:
            self: DirExVis sınıfının nesnesi.

        Returns:
            None
        """
        os.chdir(self.path)
        with open(
            "DirExVis_"
            + self.unixToDate(datetime.datetime.now().timestamp()).replace(":", ".")
            + ".txt",
            "w",
        ) as f:
            f.write(self.data_str)
        print("File saved at:", os.getcwd(), " and its starts by: DirExVis_******.txt")

    def start(self):
        self.datas = {self.path: [0, "dir", 0, os.path.getmtime(self.path), {}]}
        self.printAll({self.path: self.datas[self.path]})
        self.walker(self.path, 0, self.datas[self.path][4])


if __name__ == "__main__":
    DirExVis()  # you can add here full path
</code></pre>
            </section>
        </main>
        <aside id="aside" name="aside" role="complementary" aria-label="Yan içerik"></aside>
    </div>
    <script class="alternatively" src="./../src/components/importHeaderFooter.js" type="text/javascript" defer></script>
    <script class="alternatively" src="../page_asides.js" type="text/javascript" defer></script>
    <script>
        // alternatif kaynaklar: { name: ["link"/"script",  last_used_index, altertatives... ] }
        const kaynaklar = {
            'importHeaderFooter.js': [0, "./../src/components/importHeaderFooter.js", "/src/components/importHeaderFooter.js"],
            'headerFooter.css': [0, "../../src/components/headerFooter.css", "/src/components/headerFooter.css"],
            'page_asides.js': [0, "../page_asides.js", "/projects/page_asides.js"],
            'page_aside.css': [0, "../page_aside.css", "/projects/page_aside.css"],
        }
        // Alternatif kaynaklara domain ekleyerek kontrol et
        Object.keys(kaynaklar).forEach(name => { kaynaklar[name].push(...kaynaklar[name].slice(1).map(path => `${window.location.host}/${path}`.replace(/\/{2,}/g, '/'))); });

        // her dosya'in alternatif kaynaklarını belirle
        document.querySelectorAll(".alternatively").forEach(element => {
            const fileName = element.src ? element.src.split("/").pop() : element.href ? element.href.split("/").pop() : null;
            if (!fileName) return;
            if (kaynaklar[fileName]) {
                console.log(`Dosya için alternatif kaynaklar belirlendi: (${fileName})`);
                if (fileName.endsWith(".js")) element.onerror = () => loadFallbackScript(fileName);
                else if (fileName.endsWith(".css")) { setTimeout(() => { if (!isStylesheetLoadedByHref(fileName)) loadFallbackScript(fileName) }, 1000); }
                else console.log(`Dosya türü desteklenmiyor: ${fileName}`);
                element.onerror = () => loadFallbackScript(fileName);
            } else console.log(`Dosya için alternatif kaynak bulunamadı: '${fileName}'`);
        });

        // alternatif kaynaklardan yükleme fonksiyonu
        function loadFallbackScript(fileName) {
            const fileIndex = ++kaynaklar[fileName][0];
            if (fileIndex >= kaynaklar[fileName].length) { console.log(`Tüm alternatif kaynaklar denendi, yükleme başarısız: ${fileName}`); return; }

            console.log('Dosya için alternatif kaynak yükleniyor (' + fileName + ',  alternatif-' + fileIndex + ')\n ---> \'' + kaynaklar[fileName][fileIndex] + '\'');
            if (fileName.endsWith(".js")) {
                const fallbackScript = document.createElement('script');
                fallbackScript.type = 'text/javascript';
                fallbackScript.src = kaynaklar[fileName][fileIndex];
                fallbackScript.defer = true;
                fallbackScript.onerror = () => loadFallbackScript(fileName);
                document.head.appendChild(fallbackScript);
            }
            else if (fileName.endsWith(".css")) {
                if (isStylesheetLoadedByHref(fileName)) return;
                const fallbackLink = document.createElement('link');
                fallbackLink.rel = 'stylesheet';
                fallbackLink.href = kaynaklar[fileName][fileIndex];
                setTimeout(() => { if (!isStylesheetLoadedByHref(fileName)) loadFallbackScript(fileName) }, 1000);
                document.head.appendChild(fallbackLink);
            }
            else console.log(`Dosya türü desteklenmiyor: ${fileName}`);
        }

        function isStylesheetLoadedByHref(href) { return Array.from(document.styleSheets).some(sheet => { if (sheet.href && sheet.href.includes(href)) { try { return sheet.cssRules.length > 0; } catch (e) { return false; /*CORS hatası perhebs*/ } } return false; }); }
    </script>
</body>

</html>