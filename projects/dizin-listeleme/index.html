<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Language" content="tr" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- SEO Meta Etiketleri -->
    <title>Dizin Listeme (python) | MEFAMEX-PROJECTS</title>
    <meta name="author" content="Mefamex" />
    <meta name="description" content="Proje ismi: Dizin-listeleme | YazÄ±lÄ±m Dili: Python | AÃ§Ä±klama: Dizindeki dosyalar ve klasÃ¶rlerin komut istemcisi Ã¼zerinde ayrÄ±ntÄ±larÄ±ntÄ±larÄ±nÄ± gÃ¶rme." />
    <meta name="keywords" content="project, proje, mefamex proje, file lister, dizin listeleme, python, python project" />
    <meta name="robots" content="index, follow, max-image-preview:large" />
    <meta name="googlebot" content="index, follow" />
    <!-- Preconnect ve DNS Prefetch -->
    <link rel="preconnect" href="https://mefamex.com" />
    <link rel="dns-prefetch" href="https://mefamex.com" />
    <!-- Canonical Link -->
    <link rel="canonical" href="https://mefamex.com/projects/dizin-listeleme/" />
    <!-- Stil Optimizasyonu -->
    <link rel="stylesheet" href="/projects/page_aside.css" class="alternatively" />
    <link rel="preload" as="style" href="/src/components/headerFooter.css" class="alternatively" />
    <link rel="preload" as="script" href="/src/components/importHeaderFooter.js" />
    <!-- favicon set -->
    <link rel="icon" sizes="16x16" href="/src/assets/images/mfmx/mfmx-16.png" type="image/png" />
    <link rel="icon" sizes="32x32" href="/src/assets/images/mfmx/mfmx-32.png" type="image/png" />
    <link rel="icon" sizes="64x64" href="/src/assets/images/mfmx/mfmx-64.png" type="image/png" />
    <link rel="icon" sizes="144x144" href="/src/assets/images/mfmx/mfmx-144.png" type="image/png" />
    <link rel="icon" sizes="256x256" href="/src/assets/images/mfmx/mfmx-256.png" type="image/png" />
    <link rel="icon" sizes="512x512" href="/src/assets/images/mfmx/mfmx-512.png" type="image/png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/src/assets/images/mfmx/mfmx-144.png" />
    <!-- Open Graph Meta Etiketleri -->
    <meta property="og:title" content="Dizin Listeme (python) | MEFAMEX-PROJECTS" />
    <meta property="og:description"
        content="Dizin YapÄ±sÄ± GÃ¶rselleÅŸtirme AracÄ±: Python ile yazÄ±lmÄ±ÅŸ, dizinlerdeki dosya ve klasÃ¶rlerin detaylÄ± analizini yaparak disk kullanÄ±mÄ±nÄ± optimize etmeye yardÄ±mcÄ± olan bir uygulama." />
    <meta property="og:image" content="https://mefamex.com/src/assets/images/mfmx/mfmx-144.png" />
    <meta property="og:url" content="https://mefamex.com/projects/dizin-listeleme/" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="MEFAMEX" />
    <meta property="article:modified_time" content="2025-03-13T02:00:00Z" />
    <!-- Twitter Meta Etiketleri -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="Mefamex" />
    <meta name="twitter:creator" content="@mefamex" />
    <meta name="twitter:title" content="Dizin Listeme (python) | MEFAMEX-PROJECTS" />
    <meta name="twitter:description"
        content="Dizin YapÄ±sÄ± GÃ¶rselleÅŸtirme AracÄ±: Python ile yazÄ±lmÄ±ÅŸ, dizinlerdeki dosya ve klasÃ¶rlerin detaylÄ± analizini yaparak disk kullanÄ±mÄ±nÄ± optimize etmeye yardÄ±mcÄ± olan bir uygulama." />
    <meta name="twitter:image" content="https://mefamex.com/src/assets/images/mfmx/mfmx-144.png" />
    <meta name="twitter:url" content="https://mefamex.com/projects/dizin-listeleme/" />
    <meta name="twitter:type" content="website" />
    <meta name="twitter:date" content="2025-03-13T02:00:00Z" />
    <style>
        #main_container main section {
            flex: 1 1 35rem;
            min-height: 10rem;
            width: 30rem;
        }
    </style>
    <!---->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" defer>  </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js" defer>  </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" defer>  </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js" defer>  </script>
</head>

<body>
    <div id="main_container">
        <main role="main" id="main" name="main" aria-label="Ana iÃ§erik">
            <section id="mainWellcome">
                <h1>DÄ°ZÄ°N LÄ°STELEME</h1>
                <p>Bu Python uygulamasÄ±, belirtilen bir dizin yolundaki tÃ¼m dosya ve dizinleri detaylÄ± bir gÃ¶rselleÅŸtirir.</p>
                <p>Dosya boyutlarÄ±, oluÅŸturulma tarihleri, dizin hiyerarÅŸisi gibi bilgileri gÃ¶rsel ve metinsel olarak sunar.</p>
                <p>Github Proje SayfasÄ±: <a href="https://github.com/Mefamex/Directory_Explorer">github.com/Mefamex/Directory_Explorer</a></p>
            </section>
            <section>
                <h2>Ana Ã–zellikler: </h2>
                <ul>
                    <li>RekÃ¼rsif Dizin Gezimi:** Belirtilen dizin ve tÃ¼m alt dizinlerini inceler.</li>
                    <li>DetaylÄ± Bilgi Toplama:** Dosya boyutu, oluÅŸturulma tarihi, dizin derinliÄŸi gibi bilgileri hesaplar.</li>
                    <li>FormatlÄ± Ã‡Ä±kÄ±ÅŸ:** Tablo ÅŸeklinde okunaklÄ± bir terminal Ã§Ä±ktÄ±sÄ± sunar.</li>
                    <li>Metin DosyasÄ±na Kaydetme:** SonuÃ§larÄ± bir metin dosyasÄ±na kaydeder.</li>
                    <li>Ã–zelleÅŸtirilebilir:** Ã‡Ä±kÄ±ÅŸ formatÄ±, analiz derinliÄŸi gibi ayarlar yapÄ±labilir.</li>
                </ul>
            </section>
            <section>
                <h2>KullanÄ±lan ModÃ¼ller:</h2>
                <ul>
                    <li>os</li>
                    <li>datetime</li>
                </ul>
            </section>
            <section class="section_full">
                <h2>Script (python)</h2>
                <!--code tag with pre attribute bot not with pre tag-->
                <pre class="line-numbers"><code  class="language-python"># -*- coding: utf-8 -*-
# Created on Sunday, August 25 13:30:00 2024
# @author: mefamex

print(
    "\n",
    "#" * 30,
    """
    **Dizin YapÄ±sÄ± GÃ¶rselleÅŸtirme AracÄ±**

    Bu Python uygulamasÄ±, belirtilen bir dizin yolundaki tÃ¼m dosya ve dizinleri detaylÄ± bir ÅŸekilde analiz eder.
    Dosya boyutlarÄ±, oluÅŸturulma tarihleri, dizin hiyerarÅŸisi gibi bilgileri gÃ¶rsel ve metinsel olarak sunar.
    Sistem yÃ¶neticileri, geliÅŸtiriciler ve veri bilimcileri iÃ§in disk kullanÄ±mÄ±nÄ± optimize etmek, dosya yÃ¶netimini
    kolaylaÅŸtÄ±rmak ve veri analizi yapmak iÃ§in ideal bir araÃ§tÄ±r.

    **Ana Ã–zellikler:**
    * **RekÃ¼rsif Dizin Gezimi:** Belirtilen dizin ve tÃ¼m alt dizinlerini inceler.
    * **DetaylÄ± Bilgi Toplama:** Dosya boyutu, oluÅŸturulma tarihi, dizin derinliÄŸi gibi bilgileri hesaplar.
    * **FormatlÄ± Ã‡Ä±kÄ±ÅŸ:** Tablo ÅŸeklinde okunaklÄ± bir terminal Ã§Ä±ktÄ±sÄ± sunar.
    * **Metin DosyasÄ±na Kaydetme:** SonuÃ§larÄ± bir metin dosyasÄ±na kaydeder.
    * **Ã–zelleÅŸtirilebilir:** Ã‡Ä±kÄ±ÅŸ formatÄ±, analiz derinliÄŸi gibi ayarlar yapÄ±labilir.

    **KullanÄ±lan ModÃ¼ller:**
    * os modÃ¼lÃ¼
    * datetime modÃ¼lÃ¼

    **UyarÄ±lar:**
    * Ã‡ok bÃ¼yÃ¼k dizinlerde performans dÃ¼ÅŸÃ¼ÅŸÃ¼ yaÅŸanabilir.
    * Dosya eriÅŸim haklarÄ± konusunda dikkatli olunmalÄ±dÄ±r.
##################################################################################""",
    sep="",
)

import os, datetime


class DirExVis:
    """This class walks a directory tree, gathers information about files and directories, and presents it in a formatted way.

    Bu sÄ±nÄ±f, bir dizin yapÄ±sÄ±nÄ± gezerek, dosya ve dizinler hakkÄ±nda bilgi toplar ve biÃ§imlendirilmiÅŸ bir ÅŸekilde sunar.
    """

    tab_size: int = 4
    details_size, details_date, details_folderCount = False, False, False
    width: int = 35
    maxNameLength: list = [0, 0]  # name, depth

    @staticmethod
    def unixToDate(unix: int | float) -> str:
        """Unix zaman damgasÄ±nÄ± okunabilir bir tarih ve saat dizesine Ã§evirir.
        Args:
            unix (int | float): Unix zaman damgasÄ± (epoch'tan itibaren geÃ§en saniye sayÄ±sÄ±).
        Returns:
            str: BiÃ§imlendirilmiÅŸ tarih ve saat dizesi (YYYY-MM-DD HH:MM:SS)."""
        return datetime.datetime.fromtimestamp(unix).strftime("%Y-%m-%d %H:%M:%S")

    def __init__(self, path: str = "", data: dict = {}):
        """This method initializes the DirExVis class.
            It takes an optional path argument, which specifies the starting directory.
            It also takes an optional data dictionary to store file and directory information.

        Args:
            path (str, optional): The starting directory path. Defaults to the current working directory.
            data (dict, optional): A dictionary to store file and directory information. Defaults to an empty dictionary.

        Bu method DirExVis sÄ±nÄ±fÄ±nÄ± baÅŸlatÄ±r.
        Ä°steÄŸe baÄŸlÄ± olarak bir baÅŸlangÄ±Ã§ dizini yolu alan bir path argÃ¼manÄ± alÄ±r.
        AyrÄ±ca, dosya ve dizin bilgilerini saklamak iÃ§in isteÄŸe baÄŸlÄ± bir data sÃ¶zlÃ¼ÄŸÃ¼ alÄ±r.

        Args:
            path (str, isteÄŸe baÄŸlÄ±): BaÅŸlangÄ±Ã§ dizini yolu. VarsayÄ±lan olarak mevcut Ã§alÄ±ÅŸma dizini.
            data (dict, isteÄŸe baÄŸlÄ±): Dosya ve dizin bilgilerini saklamak iÃ§in bir sÃ¶zlÃ¼k. VarsayÄ±lan olarak boÅŸ bir sÃ¶zlÃ¼k.
        """
        self.path: str = path if path != "" else os.getcwd()
        os.chdir(self.path)
        self.path = os.getcwd()
        self.datas: dict = (
            {}
        )  # { "name" : [depth(int) ,type (file/dir) , size , date , {childs}]  }

        self.data_str: str = ""
        self.printAll_dotted: bool = True
        self.start()
        self.saveDirExVis()

    def walker(self, path="", depth=0, data: dict = None):
        """Recursively traverses a directory structure and collects file and directory information.

                This method systematically explores a directory and its subdirectories, gathering details
                about each file and directory encountered. Collected information includes the file or
                directory name, type, size, modification time, and depth within the directory hierarchy.
                The gathered data is stored in a dictionary for further processing or analysis.

        Args:
            self: A reference to the `DirExVis` object.
            path (str, optional): The path of the directory to start traversing. Defaults to the current directory.
            depth (int, optional): The current depth level within the directory structure. Defaults to 0.
            data (dict, optional): A dictionary to store file and directory information. Defaults to `self.datas`.

        Returns:
            None


        Bu metot, belirtilen bir dizin yolundan baÅŸlayarak tÃ¼m alt dizinleri ve dosyalarÄ± rekÃ¼rsif olarak inceler.
                Her bir dosya veya dizin iÃ§in belirli bilgileri (ad, tÃ¼r, boyut, son deÄŸiÅŸtirme tarihi, derinlik)
                toplar ve `data` sÃ¶zlÃ¼ÄŸÃ¼nde saklar.

        Args:
            self: DirExVis sÄ±nÄ±fÄ±nÄ±n bir Ã¶rneÄŸi.
            path (str, optional): Gezinilecek dizinin yolu. VarsayÄ±lan olarak mevcut Ã§alÄ±ÅŸma dizini.
            depth (int, optional): Gezinilen dizinin derinliÄŸi. VarsayÄ±lan olarak 0.
            data (dict, optional): Dosya ve dizin bilgilerini saklamak iÃ§in bir sÃ¶zlÃ¼k. VarsayÄ±lan olarak `self.datas`.

        Returns:
            None
        """

        if path == "":
            path = self.path + ""
        if data is None:
            data = self.datas
        files = []
        for entry in os.listdir(path):
            entry_path = os.path.join(path, entry)
            if os.path.isdir(entry_path):
                data[entry] = [
                    depth + 1,
                    "dir",
                    0,
                    self.unixToDate(os.path.getmtime(entry_path)),
                    {},
                ]
                maxNameLength = [
                    max(DirExVis.maxNameLength[0], len(entry)),
                    max(DirExVis.maxNameLength[1], depth),
                ]
                self.printAll(data={entry: data[entry]})
                self.walker(entry_path, depth=depth + 1, data=data[entry][4])
            else:
                files.append(entry)

        for file in files:
            os.chdir(path)
            size = os.path.getsize(file)
            mtime = self.unixToDate(os.path.getmtime(file))
            DirExVis.maxNameLength[0] = max(DirExVis.maxNameLength[0], len(file))
            data[file] = [depth + 1, " file", size, mtime]
            self.printAll(data={file: data[file]})

    def printAll(self, data={}):
        """Recursively prints file and directory information in a formatted manner.

        This method iterates through the provided `data` dictionary, which contains information about files and directories.
        It formats the output using indentation, size, date, and folder count information, and prints it to the console.
        The method also recursively calls itself to print information for subdirectories.

        Args:
            self: A reference to the `DirExVis` object.
            data (dict, optional): A dictionary containing file and directory information. Defaults to `self.datas`.

        Returns:
            None

        Dosya ve dizin bilgilerini formatlÄ± bir ÅŸekilde ekrana yazdÄ±rÄ±r.

            Bu metot, verilen `data` sÃ¶zlÃ¼ÄŸÃ¼ndeki dosya ve dizin bilgilerini alÄ±r ve indentasyon, boyut, tarih ve klasÃ¶r sayÄ±sÄ±
            gibi bilgileri kullanarak formatlar. Sonra bu formatlanmÄ±ÅŸ Ã§Ä±ktÄ±yÄ± ekrana yazdÄ±rÄ±r. Alt dizinler iÃ§in de
            aynÄ± iÅŸlemi tekrarlar.

        Args:
            self: DirExVis sÄ±nÄ±fÄ±nÄ±n nesnesi .
            data (dict, optional): Dosya ve dizin bilgilerini iÃ§eren bir sÃ¶zlÃ¼k. VarsayÄ±lan olarak `self.datas`'Ä± kullanÄ±r.

        Returns:
            None
        """

        if data == {}:
            data = self.datas
        for key in data.keys():
            value = data[key]
            bas: str = ("|" + " " * DirExVis.tab_size) * value[0]
            folderCount: str = (
                ("(" + str(len(value[4])) + ")" if value[1] == "dir" else "")
                if DirExVis.details_folderCount
                else ""
            )
            size: str = (
                str(round(value[2] / (1024 * 1024), 3)) + "mb "
                if DirExVis.details_size
                else ""
            )
            date: str = str(value[3]) if DirExVis.details_date else ""
            arabosluk: str = (
                " "
                * (
                    DirExVis.width
                    + DirExVis.maxNameLength[0]
                    + DirExVis.maxNameLength[1] * DirExVis.tab_size
                    - len(bas + key + folderCount + size + date)
                )
                if len(size + date) > 0
                else ""
            )
            self.printAll_dotted = not self.printAll_dotted
            if self.printAll_dotted:
                arabosluk = arabosluk.replace(" ", "-")
            self.data_str += f"{bas}{key}{folderCount}{arabosluk}{size}{date}\n"
            print(f"{bas}{key}{folderCount}{arabosluk}{size}{date}")
            if value[1] == "dir" and len(value[4]) > 0:
                self.printAll(value[4])

    def saveDirExVis(self):
        """Saves the collected file and directory information to a text file.

        This method writes the formatted output of the file and directory structure to a text file.
        The formatted output is stored in the `data_str` attribute of the `DirExVis` object.

        Filename Generation:
            * A unique filename is created starting with "DirExVis_".
            * The current timestamp is appended in a human-readable format (replacing colons with periods).
            * A ".txt" extension is added to indicate a text file. This ensures that each save operation creates a new file.

        Data Saving:
            * The `data_str` attribute, containing the formatted output, is written to the newly created file.

        Args:
            self: A reference to the `DirExVis` object.

        Returns:
            None

        Toplanan dosya ve dizin bilgilerini bir metin dosyasÄ±na kaydeder.

        Bu metot, `walker` metodu tarafÄ±ndan toplanan dosya ve dizin bilgilerini okunaklÄ± bir
        ÅŸekilde bir metin dosyasÄ±na kaydeder. Kaydedilen bilgiler, `printAll` metodu tarafÄ±ndan
        oluÅŸturulan `data_str` deÄŸiÅŸkeninde saklanÄ±r.

        Dosya AdÄ± OluÅŸturma:
            * Dosya adÄ± "DirExVis_" ile baÅŸlar.
            * ArdÄ±ndan, geÃ§erli zaman damgasÄ± insan tarafÄ±ndan okunabilir
                bir formata dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r (iki nokta yerine nokta kullanÄ±lÄ±r).
            * Son olarak, ".txt" uzantÄ±sÄ± eklenir. Bu sayede, benzersiz
                bir dosya adÄ± oluÅŸturulur ve mevcut dosyalarÄ±n Ã¼zerine yazÄ±lmaz.

        Veri Kaydetme:
            * `data_str` deÄŸiÅŸkeni, aÃ§Ä±lan metin dosyasÄ±na yazÄ±lÄ±r.

        Args:
            self: DirExVis sÄ±nÄ±fÄ±nÄ±n nesnesi.

        Returns:
            None
        """
        os.chdir(self.path)
        with open(
            "DirExVis_"
            + self.unixToDate(datetime.datetime.now().timestamp()).replace(":", ".")
            + ".txt",
            "w",
        ) as f:
            f.write(self.data_str)
        print("File saved at:", os.getcwd(), " and its starts by: DirExVis_******.txt")

    def start(self):
        self.datas = {self.path: [0, "dir", 0, os.path.getmtime(self.path), {}]}
        self.printAll({self.path: self.datas[self.path]})
        self.walker(self.path, 0, self.datas[self.path][4])


if __name__ == "__main__":
    DirExVis()  # you can add here full path
</code></pre>
            </section>
        </main>
        <aside id="aside" name="aside" role="complementary" aria-label="Yan iÃ§erik"></aside>
    </div>
    <script class="alternatively" src="/src/components/importHeaderFooter.js"></script>
    <script class="alternatively" src="/projects/page_aside.js" defer></script>
    <script id="alternativelyJS" type="text/javascript" defer>
        /*  class="alternatively"  */
        /* alternatif kaynaklar: { name: [ subelement , last_used_index, altertatives... ] } */
        const kaynaklar = {};
        const urlObj = new URL(location.href);
        const { host, origin } = urlObj;
        const targetElements = document.querySelectorAll(".alternatively");
        const firstSegment = urlObj.pathname.replace(/^\//, '').split('/')[0] || null;
        targetElements.forEach(element => {
            const path = (element.getAttribute('src') || element.getAttribute('href')); if (!path) return;
            const fileName = path.split('/').pop(); if (!fileName) return;
            const cleanPath = path.replace(/\.\.\//g, '').replace(/\.\//g, '').replace(/\/+/g, '/');
            kaynaklar[fileName] = [element, 1, path, `./${cleanPath}`, `/${firstSegment}/${cleanPath}`, `${origin}/${cleanPath}`, `${origin}/${firstSegment}/${cleanPath}`, `${host}/${cleanPath}`, `${host}/${firstSegment}/${cleanPath}`];
            if (host != 'mefamex.com') { kaynaklar[fileName].push(`mefamex.com/${cleanPath}`, `mefamex.com/${firstSegment}/${cleanPath}`, `https://mefamex.com/${cleanPath}`, `https://mefamex.com/${firstSegment}/${cleanPath}`); }
        });
        async function initializeAlternatives() { await Promise.all(Array.from(targetElements).map(element => initializeResource(element).catch(error => console.error(`âš ï¸ Kaynak baÅŸlatÄ±lÄ±rken hata: ${error.message}`)))); }
        (async () => { await initializeAlternatives(); })();
        async function initializeResource(element) {
            const fileName = element.src ? element.src.split("/").pop() : element.href ? element.href.split("/").pop() : null;
            if (!fileName) return;
            if (kaynaklar[fileName]) {
                console.log(`ğŸ”„ Dosya iÃ§in alternatif kaynaklar belirlendi (${kaynaklar[fileName].length - 2}): ${fileName}`);
                if (fileName.endsWith(".js")) { element.onerror = () => checkScriptLoaded(element, fileName); element.onload = () => checkScriptLoaded(element, fileName); }
                else if (fileName.endsWith(".css")) { (async () => checkStyleLoaded(element, fileName))(); }
                else console.log(`âŒ Dosya tÃ¼rÃ¼ desteklenmiyor: ${fileName}`);
            } else console.log(`âš ï¸ Dosya iÃ§in alternatif kaynak bulunamadÄ±: '${fileName}'`);
        }
        function loadFallbackScript(fileName) {
            const subelement = kaynaklar[fileName][0];
            const fileIndex = ++kaynaklar[fileName][1];
            if (fileIndex >= kaynaklar[fileName].length) { console.log(`TÃ¼m alternatif kaynaklar denendi, yÃ¼kleme baÅŸarÄ±sÄ±z: ${fileName}`); return; }
            console.log('â³ Dosya iÃ§in alternatif kaynak yÃ¼kleniyor : ' + fileName + ' (' + fileIndex + ')\n -------> \'' + kaynaklar[fileName][fileIndex] + '\'');
            if (fileName.endsWith(".js")) {
                const fallbackScript = document.createElement('script');
                fallbackScript.src = kaynaklar[fileName][fileIndex];
                /* TÃ¼m Ã¶zellikleri kopyala (src, onerror, onload ve alternatively sÄ±nÄ±fÄ± hariÃ§) */
                Array.from(subelement.attributes).forEach(attr => { if (!['src', 'onerror', 'onload', 'class'].includes(attr.name)) fallbackScript.setAttribute(attr.name, attr.value); });
                if (subelement.hasAttribute('class')) { const classes = subelement.getAttribute('class').split(' ').filter(c => c !== 'alternatively').join(' '); if (classes) fallbackScript.setAttribute('class', classes); }
                fallbackScript.onerror = () => checkScriptLoaded(fallbackScript, fileName); fallbackScript.onload = () => checkScriptLoaded(fallbackScript, fileName);
                document.head.appendChild(fallbackScript);
            } else if (fileName.endsWith(".css")) {
                const fragment = document.createDocumentFragment();
                const fallbackLink = document.createElement('link'); fallbackLink.href = kaynaklar[fileName][fileIndex]; fallbackLink.rel = 'stylesheet'; fallbackLink.type = 'text/css';
                fragment.appendChild(fallbackLink);
                document.head.appendChild(fragment); checkStyleLoaded(fallbackLink, fileName);
            } else console.log(`Dosya tÃ¼rÃ¼ desteklenmiyor: ${fileName}`);
        }
        async function checkStyleLoaded(element, fileName) {
            let maxAttempts = 10; let isLoaded = false;
            return new Promise((resolve, reject) => {
                element.onerror = () => { console.error(`âŒ CSS yÃ¼klenemedi: ${fileName}`); reject(new Error('CSS yÃ¼kleme hatasÄ±')); };
                element.onload = () => { isLoaded = true; clearInterval(checkInterval); resolve(true); };
                const checkInterval = setInterval(async () => {
                    if (--maxAttempts <= 0) { clearInterval(checkInterval); if (!isLoaded) { console.warn(`âš ï¸ CSS yÃ¼kleme zaman aÅŸÄ±mÄ±: ${fileName}`); loadFallbackScript(fileName); reject(new Error('CSS yÃ¼kleme zaman aÅŸÄ±mÄ±')); } return; }
                    try { const loaded = await isStylesheetLoadedByHref(fileName); if (loaded) { isLoaded = true; clearInterval(checkInterval); resolve(true); } } catch (error) { loadFallbackScript(fileName); console.error('CSS kontrol hatasÄ±:', error); }
                }, 500);
            });
        }
        function isStylesheetLoadedByHref(href) {
            const sheets = Array.from(document.styleSheets);
            let loaded = false;
            return new Promise(resolve => {
                loaded = sheets.some(sheet => {
                    if (!sheet.href) { return false; }
                    if (sheet.href.includes(href)) {
                        try { const hasRules = sheet.cssRules.length > 0; if (hasRules) { console.log(`âœ… ${href} baÅŸarÄ±yla yÃ¼klendi.`); return true; } } catch (e) { return false;/* CORS hatasÄ± veya diÄŸer hatalar */ }
                    } return false;
                }); resolve(loaded);
            });
            /*return new Promise(resolve => { const check = () => { const loaded = Array.from(document.styleSheets).some(sheet => sheet.href && sheet.href.includes(href));  if (loaded) resolve(true); else requestAnimationFrame(check); };requestAnimationFrame(check); });*/
        }
        function checkScriptLoaded(element, fileName) {
            if (element.dataset.failed) { console.warn(`Hata: ${element.src} yÃ¼klenemedi. Alternatif kaynak yÃ¼kleniyor...`); loadFallbackScript(fileName); return; }
            if (element.readyState === 'complete' || element.readyState === 'loaded') { approvedLoad(); return; }
            setTimeout(async () => {
                try {
                    fetch(element.src, { method: "HEAD" })
                        .then(response => {
                            const contentType = response.headers.get("Content-Type") || ""; if (contentType.includes("javascript") || contentType.includes("text/js")) { approvedLoad(); } else {
                                if (element.textContent && element.textContent.length > 0) { approvedLoad('iÃ§erik kontrolÃ¼'); } else { failedToLoad(`GeÃ§ersiz iÃ§erik tÃ¼rÃ¼: ${contentType}`); }
                            }
                        })
                        .catch(() => { if (element.textContent && element.textContent.length > 0) { approvedLoad('iÃ§erik kontrolÃ¼'); } else { console.error(`âš ï¸ ${fileName} doÄŸrulanamadÄ±.`); loadFallbackScript(fileName); } });
                } catch (error) { failedToLoad("DoÄŸrulanamadÄ±"); }
            }, 500);
            function failedToLoad(text = "") {
                element.dataset.failed = true; element.onerror = null; element.onload = null;
                console.error(`âŒ Hata (${kaynaklar[fileName][1]}): ${fileName} yÃ¼klenemedi ${text ? '(' + text + ')' : ""}. Alternatif kaynak yÃ¼kleniyor...`);
                element.remove(); loadFallbackScript(fileName);
            }
            function approvedLoad(text = "") { console.log(`âœ… ${fileName} baÅŸarÄ±yla yÃ¼klendi ${text ? '(' + text + ')' : ""}.`); }
        }
    </script>
</body>

</html>